1. 简单难度：排序数组（归并排序实现）
题号：LeetCode 912. Sort an Array
核心考点：分治算法的经典应用 —— 归并排序，理解 “分解 - 排序 - 合并” 的完整流程。
分治思路：
分解：将数组从中间分成左右两个子数组，递归分解直到每个子数组只有 1 个元素（单个元素天然有序）。
解决子问题：对左右两个有序子数组执行 “合并” 操作，生成一个新的有序数组。
合并：用双指针分别遍历两个子数组，每次选择较小的元素放入临时数组，最终将临时数组拷贝回原数组。
关键代码片段（合并步骤）：
python
运行
def merge(nums, left, mid, right):
    temp = []
    i, j = left, mid + 1  # 左子数组起点、右子数组起点
    while i <= mid and j <= right:
        if nums[i] <= nums[j]:
            temp.append(nums[i])
            i += 1
        else:
            temp.append(nums[j])
            j += 1
    
    temp.extend(nums[i:mid+1])
    temp.extend(nums[j:right+1])
    nums[left:right+1] = temp  # 拷贝回原数组

2. 中等难度：数组中的第 K 个最大元素
题号：LeetCode 215. Kth Largest Element in an Array
核心考点：分治思想的优化应用 —— 快速选择算法（Quick Select），比排序后取第 K 位更高效（平均时间复杂度 O (n)）。
分治思路：
分解：借鉴快速排序的 “partition（分区）” 操作，随机选择一个 “基准数”，将数组分成两部分：
左部分：所有元素 > 基准数（降序分区，方便直接定位第 K 大）；
右部分：所有元素 ≤ 基准数。
解决子问题：判断基准数的位置 p 与目标 K-1（数组索引从 0 开始）的关系：
若 p == K-1：基准数就是第 K 大元素，直接返回；
若 p > K-1：第 K 大元素在左子数组，递归左子数组；
若 p < K-1：第 K 大元素在右子数组，递归右子数组。
合并：无需合并（子问题的解就是原问题的解）。
关键提示：随机选择基准数可避免最坏情况（如数组已排序时时间复杂度退化到 O (n²)）。
3. 中等难度：从前序与中序遍历序列构造二叉树
题号：LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal
核心考点：分治在树结构中的应用 —— 通过遍历序列的特性分解 “根 - 左子树 - 右子树”。
分治思路：
分解：
前序遍历的第一个元素是当前树的 根节点；
在中序遍历中找到根节点的位置 mid，则中序数组分为：
左子树：inorder[left..mid-1]（长度为 mid-left）；
右子树：inorder[mid+1..right]。
前序数组也对应分为：
左子树：preorder[left+1..left+mid-left]（根节点后，长度与中序左子树一致）；
右子树：preorder[left+mid-left+1..right]。
解决子问题：递归构造左子树和右子树。
合并：将左子树和右子树挂载到根节点上。
关键示例：
前序：[3,9,20,15,7]，中序：[9,3,15,20,7]
根是 3，中序左子树 [9]、右子树 [15,20,7]，递归构造即可。
4. 中等难度：电话号码的字母组合
题号：LeetCode 17. Letter Combinations of a Phone Number
核心考点：分治与回溯的结合（分治视角：将字符串拆分为两部分，分别求组合后再交叉相乘）。
分治思路：
分解：将输入的数字字符串 digits 拆分为左半部分 left 和右半部分 right（如 digits="23" 拆为 "2" 和 "3"）。
解决子问题：递归求 left 对应的字母组合列表 list1，以及 right 对应的字母组合列表 list2。
合并：将 list1 和 list2 中的元素两两拼接，生成最终的组合列表（如 list1=["a","b","c"]，list2=["d","e","f"]，合并为 ["ad","ae","af","bd",...]）。
边界条件：若 digits 为空，返回空列表；若 digits 只有 1 个数字，直接返回该数字对应的字母列表。
5. 困难难度：合并 K 个升序链表
题号：LeetCode 23. Merge k Sorted Lists
核心考点：分治优化 “多链表合并”—— 将 K 个链表的合并拆解为 “两两合并”，避免暴力合并的低效（时间复杂度从 O (KN) 优化到 O (NlogK)，N 是所有链表的总节点数）。
分治思路：
分解：将 K 个链表的列表从中间分成左右两个子列表（如 [L1,L2,L3,L4] 拆为 [L1,L2] 和 [L3,L4]），递归分解直到每个子列表只有 1 个链表（单个链表天然有序）。
解决子问题：对两个有序链表执行 “合并两个升序链表” 的操作（LeetCode 21. 简单题），生成一个新的有序链表。
合并：将所有子列表合并后的结果再次合并，最终得到一个包含所有节点的升序链表。
关键提示：合并两个升序链表时，用虚拟头节点（dummy）简化边界处理。
6. 困难难度：翻转对
题号：LeetCode 493. Reverse Pairs
核心考点：分治与归并排序的结合 —— 在 “合并” 步骤中统计翻转对，避免暴力统计的 O (n²) 时间复杂度。
分治思路：
定义问题：翻转对是指 i < j 且 nums[i] > 2*nums[j] 的元素对，需统计数组中所有这样的对。
分解：将数组分成左右两个子数组，递归统计左子数组的翻转对数量 left_cnt 和右子数组的翻转对数量 right_cnt。
解决子问题：统计 “跨左右子数组” 的翻转对数量 cross_cnt（关键步骤）：
由于左右子数组已通过归并排序变得有序，可用双指针：
左指针 i 遍历左子数组，右指针 j 遍历右子数组；
若 nums[i] > 2*nums[j]，则左子数组中 i 之后的所有元素都满足条件（因左数组有序），直接累加 mid - i + 1，并移动 j；
否则移动 i。
合并：将左右子数组合并为有序数组（为上层递归的统计做准备），总翻转对数量为 left_cnt + right_cnt + cross_cnt。
分治算法解题核心总结
能否分解：原问题是否可拆分为多个结构相同、规模更小的子问题（如数组拆两半、链表拆两组）。
子问题独立：子问题的求解过程互不干扰（如左子树和右子树的构造）。
合并逻辑：子问题的解如何组合成原问题的解（如合并两个有序数组、挂载左右子树）。
建议按 “简单（912）→ 中等（215/105/17）→ 困难（23/493）” 的顺序练习，重点体会 “分解” 和 “合并” 步骤的设计 —— 这是分治算法的核心难点。
