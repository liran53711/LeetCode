# 归并排序和快速排序指导文件

## 1. 算法详细讲解

### 归并排序 (Merge Sort)
归并排序是一种基于分治策略的排序算法。它将数组分成两个大致相等的子数组，递归地对每个子数组进行排序，然后将两个有序子数组合并成一个有序数组。该算法的时间复杂度为 O(n log n)，空间复杂度为 O(n)，因为需要额外的空间来存储合并结果。它是稳定的排序算法（相同元素的相对顺序保持不变）。

- **步骤**：
    1. **分解**：如果数组长度大于1，将数组分成左右两半。
    2. **递归排序**：对左半部分和右半部分递归调用归并排序。
    3. **合并**：将两个有序子数组合并成一个有序数组。通过比较两个子数组的头部元素，选择较小的元素放入结果数组中，重复直到所有元素合并完成。

归并排序适合大数据集，因为它是稳定的且在最坏情况下也保持 O(n log n) 的性能，但它需要额外空间。

### 快速排序 (Quick Sort)
快速排序也是一种分治算法。它选择一个元素作为“枢轴”（pivot），然后将数组分成小于或等于枢轴的部分和大于枢轴的部分，递归地对这些部分排序。平均时间复杂度为 O(n log n)，最坏情况下为 O(n²)（当枢轴选择不当，如已排序数组）。空间复杂度为 O(log n)（递归栈）。它是不稳定的排序算法。

- **步骤**：
    1. **选择枢轴**：通常选择数组的第一个、最后一个或随机元素作为枢轴。
    2. **分区**：重新排列数组，使得所有小于枢轴的元素在左侧，所有大于枢轴的元素在右侧。枢轴放置在正确位置。
    3. **递归**：对左侧和右侧子数组递归调用快速排序。

快速排序在实践中非常高效，尤其当使用随机枢轴选择来避免最坏情况。它是原地排序（in-place），但递归深度可能导致栈溢出问题。

## 2. 例子演示

假设我们有一个无序数组：[5, 3, 8, 4, 2]

### 归并排序例子
1. 分解：[5, 3, 8, 4, 2] → 左：[5, 3, 8]，右：[4, 2]
2. 继续分解左：[5, 3, 8] → 左：[5]，右：[3, 8] → [3, 8] 分解为 [3] 和 [8]
3. 合并：[3] 和 [8] → [3, 8]
4. 合并：[5] 和 [3, 8] → 比较5和3，选择3；5和8，选择5；剩余8 → [3, 5, 8]
5. 分解右：[4, 2] → [4] 和 [2] → 合并：[2, 4]
6. 最终合并：[3, 5, 8] 和 [2, 4] → 比较3和2，选择2；3和4，选择3；5和4，选择4；5为空，选择5；8为空，选择8 → [2, 3, 4, 5, 8]

### 快速排序例子（假设选择最后一个元素作为枢轴）
1. 数组：[5, 3, 8, 4, 2]，枢轴=2
2. 分区：小于2的在左（无），大于2的在右：[5, 3, 8, 4]，枢轴2移到正确位置。实际分区过程：从左扫描找到大于2的，从右扫描找到小于2的，交换。最终：[ ] < 2 | [5, 3, 8, 4, 2] 但正确分区后假设为 [ ] | 2 | [5, 3, 8, 4]（简化）。
    - 更精确：初始：[5,3,8,4,2]，i=0,j=3（最后一个前），枢轴=2。
    - 扫描：5>2，不换；j左移到4>2；j到8>2；j到3>2；j到-1停止。实际标准分区：
        - 使用Hoare分区：最终可能得到 [2] | 3 | [5,8,4] 但让我们模拟标准Lomuto分区（以最后一个为枢轴）：
            - i=-1，从0到3扫描：
            - 5>2, 不换 i= -1
            - 3>2, 不换
            - 8>2, 不换
            - 4>2, 不换
            - 交换 i+1=0 和末尾：但所有>2，所以数组不变，枢轴移到0位置？ 错误。

   为简单，使用另一个数组或标准演示。实际快速排序分区：
   选择枢轴2，重新排列：小于2的无，等于2的2，大于：[5,3,8,4]。但数组小，递归左侧空，右侧[5,3,8,4]。
   继续对[5,3,8,4]，枢轴4，分区：[3] <4 |4| [5,8]
   然后递归[3]排序好；[5,8]枢轴8，分区：[5]<8|8|[]
   最终：[2,3,4,5,8]

## 3. C++代码实现的细节以及详细注释

### 归并排序 C++ 实现
```cpp
#include <vector>

// 合并两个有序子数组的函数
void merge(std::vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子数组大小
    int n2 = right - mid;     // 右子数组大小

    // 创建临时数组存储左右子数组
    std::vector<int> L(n1), R(n2);

    // 复制数据到临时数组
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // 合并临时数组回原数组
    int i = 0;  // 左子数组索引
    int j = 0;  // 右子数组索引
    int k = left;  // 原数组起始索引

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {  // 选择较小元素（稳定排序）
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // 复制剩余元素
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 归并排序递归函数
void mergeSort(std::vector<int>& arr, int left, int right) {
    if (left >= right) return;  // 基线条件：单个元素已排序

    int mid = left + (right - left) / 2;  // 计算中点，避免溢出
    mergeSort(arr, left, mid);            // 递归左半
    mergeSort(arr, mid + 1, right);       // 递归右半
    merge(arr, left, mid, right);         // 合并
}

// 使用示例
// std::vector<int> arr = {5, 3, 8, 4, 2};
// mergeSort(arr, 0, arr.size() - 1);
```

细节：使用临时向量存储子数组，确保稳定性。递归深度为 log n。

### 快速排序 C++ 实现（使用 Lomuto 分区）
```cpp
#include <vector>

// 分区函数：返回枢轴的最终位置
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为枢轴
    int i = (low - 1);      // 小于枢轴的区域索引

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {  // 如果当前元素小于枢轴
            i++;               // 扩展小于区域
            std::swap(arr[i], arr[j]);  // 交换
        }
    }
    std::swap(arr[i + 1], arr[high]);  // 将枢轴放到正确位置
    return (i + 1);                    // 返回枢轴索引
}

// 快速排序递归函数
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low >= high) return;  // 基线条件

    int pi = partition(arr, low, high);  // 分区并获取枢轴位置
    quickSort(arr, low, pi - 1);         // 递归左半
    quickSort(arr, pi + 1, high);        // 递归右半
}

// 使用示例
// std::vector<int> arr = {5, 3, 8, 4, 2};
// quickSort(arr, 0, arr.size() - 1);
```

细节：Lomuto 分区简单但在已排序数组上效率低。可用随机枢轴改进：`std::swap(arr[high], arr[low + rand() % (high - low + 1)]);`。不稳定，因为交换可能改变相等元素的顺序。

## 4. 衍生，例如可以使用相同思想解决的问题

### 归并排序的思想衍生
- **合并 K 个有序链表**：使用归并的思想，两两合并或使用优先队列（heap）模拟多路归并。
- **求逆序对**：在合并过程中计数跨越两个子数组的逆序对（如 LeetCode 剑指 Offer 51）。
- **外部排序**：当数据太大无法放入内存时，使用归并排序的分治和合并处理大文件排序。
- **并行排序**：分治适合多线程实现。

### 快速排序的思想衍生
- **快速选择 (Quick Select)**：找到数组中第 K 大的元素，只需分区后递归一边，平均 O(n) 时间（如 LeetCode 215）。
- **荷兰国旗问题**：分区扩展到三部分（小于、等于、大于），用于颜色排序等。
- **Top K 问题**：结合快速选择或堆，高效找到前 K 个元素。
- **随机化算法**：枢轴随机选择的思想用于其他随机化分治问题，如随机化二分搜索。